#+STARTUP: content

* Bugfix todo list

* Features todo list

*** DONE Map.h rewrite

I want to have a *plain*, *macro-based* map implementation.
I don't want to have a declaration macro, or it can define a list of structs at most.
I want to minimize usage of function pointers.
Macro should be relatively small.

*** TODO wikimk should not be a part of this repository
*** TODO wikimk - allow to collapse folders in a site tree
*** TODO temporary allocator/functions (malloc/sprintf/?). Reset resets all allocations
*** DONE few additions to FlagParse.h

Aliases through commands (something like "-alias:name:lopt-which-is-aliased", only long aliases supported)
Groups through new metadata entry (something like "group=<name>"), purely for pretty print

* Thinking place

** DONE new hash-map implementation

Element struct can be provided by a user, bucket should be auto-generated, map should have an ability to add custom fields.
#+NAME: hashmap_struct
#+BEGIN_SRC C
  struct map_elem_t { // User provided
  	K key;
  	...
  };
  struct map_bucket_t { // Internal
  	void* vals;
  	size_t nvals;
  };
  struct map_t { // Internal
  	map_bucket* buckets;
  	size_t nbuckets;
  	size_t (*hash_func)(const map_t* map, const void* key);
  	size_t (*keycmp_func)(const map_t* map, const void* k1, const void* k2);
  	size_t key_size = sizeof(typeof(map_elem_t));
  	size_t elem_size = sizeof(typeof(map_elem_t));
  };
  struct my_map_t { // User provided, actually not required, raw map_t can be used.
  	map_t map;
  	// Userdata
  }
  map_t* = (map_t*)&my_map_t;
  char[key_size] key = (char*)&map_elem_t;
#+END_SRC

API is based on a fact that map only require key to work. Data is completely user-defined. So let user play with it freely. Why limit to a ~val~ - let the user play with a full struct. Map only have one unified ~get_or_alloc()~ interface that either return found element or allocate new based on key given.If allocations, memory will be zero-initialized and key will be unset. Then user can do anything with a struct (at least set a proper key ;). Map can provide additional macro that will abstract get and alloc operations and respective check (element exist or not).

If ~key_size~ is set to *0* then key is treated as a pointer to a NULL-terminated data (use-case - pointer to a C-string, often used, so good to have a fast path for this). Size of a key in an element struct then assumed to be ~sizeof(char**)~.

~hash_func~ can be omitted (set to ~NULL~), this will mean that built-in hash function will be used. If ~key_size~ is zero, then key will be treated as a pointer and ~strlen~ will be used to get size of data pointed.
~keycmp_func~ can be omitted (set to ~NULL~), this will mean that ~memcmp~ will be used to compare keys. If ~key_size~ is zero, then key will be treated as a pointer and ~strcmp~ will be used.

API exposed:
#+NAME: hashmap_api
#+BEGIN_SRC C
  void* map_get(map_t* map, const void* key); // Returns NULL if no found
  void* map_get_or_alloc(map_t* map, const void* key); // Returns pointer to map_elem_t
  bool map_remove(map_t* map, const void* key); // false if key not found in map
  void map_clear(map_t* map); // Fully clears map
  void map_clear_ex(map_t* map, void (*elem_clear_func)(const map_t* map, void* elem)); // Func ptr can be NULL, then same as map_clear
#+END_SRC

Implementations (can contains pseudo code):
#+NAME: hashmap_code
#+BEGIN_SRC C
  void* map_get(map_t* map, void* key) {
  	size_t hash = 0;
  	if (map->hash_func == NULL) {
  		if (map->key_size > 0) {
  			hash = default_hash_func((char*)key, map->key_size) % map->nbuckets;
  		} else {
  			hash = default_hash_func(*((char**)key), strlen(*((char**)key))) % map->nbuckets;
  		}
  	} else {
  		hash = map->hash_func(map, key) % map->nbuckets;
  	}
  	map_bucket_t* bucket = &map->buckets[hash];
  	if (map->keycmp_func == NULL) {
  		if (map->key_size > 0) {
  			for (size_t i = 0; i < bucket->nvals; i++) {
  				if(memcmp(key, (bucket->vals + (i * map->elem_size)), map->key_size) == 0) {
  					return (bucket->vals + (i * map->elem_size));
  				}
  			}
  		} else {
  			for (size_t i = 0; i < bucket->nvals; i++) {
  				if(strcmp(*((char**)key), *((char**)(bucket->vals + (i * map->elem_size)))) == 0) {
  					return (bucket->vals + (i * map->elem_size));
  				}
  			}
  		}
  	} else {
  		for (size_t i = 0; i < bucket->nvals; i++) {
  			if (map->keycmp_func(map, key, (bucket->vals + (i * map->elem_size)))) {
  				return (bucket->vals + (i * map->elem_size));
  			}
  		}
  	}
  	return NULL;
  }
  void* map_get_or_alloc(map_t* map, void* key) {
  	size_t hash = 0;
  	if (map->hash_func == NULL) {
  		if (map->key_size > 0) {
  			hash = default_hash_func((char*)key, map->key_size) % map->nbuckets;
  		} else {
  			hash = default_hash_func(*((char**)key), strlen(*((char**)key))) % map->nbuckets;
  		}
  	} else {
  		hash = map->hash_func(map, key) % map->nbuckets;
  	}
  	map_bucket_t* bucket = &map->buckets[hash];
  	if (map->keycmp_func == NULL) {
  		if (map->key_size > 0) {
  			for (size_t i = 0; i < bucket->nvals; i++) {
  				if(memcmp(key, (bucket->vals + (i * map->elem_size)), map->key_size) == 0) {
  					return (bucket->vals + (i * map->elem_size));
  				}
  			}
  		} else {
  			for (size_t i = 0; i < bucket->nvals; i++) {
  				if(strcmp(*((char**)key), *((char**)(bucket->vals + (i * map->elem_size)))) == 0) {
  					return (bucket->vals + (i * map->elem_size));
  				}
  			}
  		}
  	} else {
  		for (size_t i = 0; i < bucket->nvals; i++) {
  			if (map->keycmp_func(map, key, (bucket->vals + (i * map->elem_size)))) {
  				return (bucket->vals + (i * map->elem_size));
  			}
  		}
  	}
  	bucket->nvals++;
  	bucket->vals = realloc(bucket->vals, bucket->nvals * map->elem_size);
  	memset((char*)bucket->vals + (bucket->nvals - 1) * map->elem_size, 0, map->elem_size);
  	return bucket->vals + ((bucket->nvals - 1) * map_.elem_size)
  		}
  bool map_remove(map_t* map, void* key) {
  	// TODO
  }
  void map_clear(map_t* map) {
  	map_clear_ex(map, NULL);
  }
  void map_clear_ex(map_t* map, void (*elem_clear_func)(const map_t* map, void* elem)) {
  	if (elem_clear_func == NULL) {
  		for (size_t i = 0; i < map->nbuckets; i++) {
  			map_bucket_t* bucket = &map->buckets[i];
  			free(bucket->vals);
  			bucket->vals = NULL;
  			bucket->nvals = 0;
  		}
  		free(map->buckets);
  		map->buckets = NULL;
  		map->nbuckets = 0;
  	} else {
  		for (size_t i = 0; i < map->nbuckets; i++) {
  			map_bucket_t* bucket = &map->buckets[i];
  			for (size_t j = 0; j < bucket->nvals; j++) {
  				elem_clear_func(map, bucket->vals + (j * map->elem_size));
  			}
  			free(bucket->vals);
  			bucket->vals = NULL;
  			bucket->nvals = 0;
  		}
  		free(map->buckets);
  		map->buckets = NULL;
  		map->nbuckets = 0;
  	}
  }
#+END_SRC

#  LocalWords:  struct structs alloc
