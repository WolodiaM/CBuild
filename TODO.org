
#+STARTUP: content

* Bugfix todo list
*** DONE force specific POSIX
Maybe POSIX_C_SOURCE=200112L
*** DONE Make all macro evaluate their argument only once.
Some macro can be an exception, but this should be noted in documentation comment. All data-structure macro should handle elements only once, unless this is impossible.
*** DONE cbuild_fs_normalize broken on utf8 path
Any valid ASCII byte cannot be a part of utf8 multi-byte character
*** DONE New Compiler/OS/API detection macro
*** DONE cbuild_proc_wait_code fixes (proper signal handling), handle errors
*** DONE cbuild_proc_wait_any implementation
*** DONE POSIX have special meaning for paths starting from '//'. Account for this during normalization
*** TODO GNU style CLI options also support ~--opt=arg~, I don't support them
*** DONE use proper argv[0] on reexec in selfrebuild, path still can be absolute
Maybe allow to pass another argument that will be used as exec path and use cmd just as argv
*** DONE cbuild_sv_utf8cmp can just be an alias to cbuild_sv_cmp.
utf8 is BE, so memcmp will properly compare chars
* Features todo list
*** DONE Map.h rewrite
I want to have a *plain*, *macro-based* map implementation.
I don't want to have a declaration macro, or it can define a list of structs at most.
I want to minimize usage of function pointers.
Macro should be relatively small.
*** TODO wikimk should not be a part of this repository
*** TODO wikimk - allow to collapse folders in a site tree
*** DONE temporary allocator/functions (malloc/sprintf/?). Reset resets all allocations
*** DONE few additions to FlagParse.h
Aliases through commands (something like "-alias:name:lopt-which-is-aliased", only long aliases supported)
Groups through new metadata entry (something like "group=<name>"), purely for pretty print
*** DONE Command.h - allow to limit number of async threads in 'cbuild_cmd_run'
Need to pass a 'cbuild_proclist_t'. Need to pass int. Now it simply checks for number of procs, if there are too much - wait for them to finnish
*** DONE Command.h - better redirects
Alow to redirect directly to file, not fd (will be autoclosed)
Maybe better piping?
*** DONE Command.h - allow to print command using single opt
*** DONE function to get time and nanosecond time in platform-independant way
*** DONE abstract filesize getting
*** DONE Proc.h - add ability to get number of CPU cores. By default command should scale to this+1 for async runs
*** DONE Export __cbuild_int_log and __cbuild_log_vlog
*** DONE Allow rewinding and rewind point for cbuild_temp_*
*** DONE cbuild_temp_sv_to_cstr(), cbuild_sv_to_cstr
* Thinking place
** DONE new hash-map implementation
Element struct can be provided by a user, bucket should be auto-generated, map should have an ability to add custom fields.
#+NAME: hashmap_struct
#+BEGIN_SRC C
  struct map_elem_t { // User provided
  	K key;
  	...
  };
  struct map_bucket_t { // Internal
  	void* vals;
  	size_t nvals;
  };
  struct map_t { // Internal
  	map_bucket* buckets;
  	size_t nbuckets;
  	size_t (*hash_func)(const map_t* map, const void* key);
  	size_t (*keycmp_func)(const map_t* map, const void* k1, const void* k2);
  	size_t key_size = sizeof(typeof(map_elem_t));
  	size_t elem_size = sizeof(typeof(map_elem_t));
  };
  struct my_map_t { // User provided, actually not required, raw map_t can be used.
  	map_t map;
  	// Userdata
  }
  map_t* = (map_t*)&my_map_t;
  char[key_size] key = (char*)&map_elem_t;
#+END_SRC

API is based on a fact that map only require key to work. Data is completely user-defined. So let user play with it freely. Why limit to a ~val~ - let the user play with a full struct. Map only have one unified ~get_or_alloc()~ interface that either return found element or allocate new based on key given.If allocations, memory will be zero-initialized and key will be unset. Then user can do anything with a struct (at least set a proper key ;). Map can provide additional macro that will abstract get and alloc operations and respective check (element exist or not).

If ~key_size~ is set to *0* then key is treated as a pointer to a NULL-terminated data (use-case - pointer to a C-string, often used, so good to have a fast path for this). Size of a key in an element struct then assumed to be ~sizeof(char**)~.

~hash_func~ can be omitted (set to ~NULL~), this will mean that built-in hash function will be used. If ~key_size~ is zero, then key will be treated as a pointer and ~strlen~ will be used to get size of data pointed.
~keycmp_func~ can be omitted (set to ~NULL~), this will mean that ~memcmp~ will be used to compare keys. If ~key_size~ is zero, then key will be treated as a pointer and ~strcmp~ will be used.

API exposed:
#+NAME: hashmap_api
#+BEGIN_SRC C
  void* map_get(map_t* map, const void* key); // Returns NULL if no found
  void* map_get_or_alloc(map_t* map, const void* key); // Returns pointer to map_elem_t
  bool map_remove(map_t* map, const void* key); // false if key not found in map
  void map_clear(map_t* map); // Fully clears map
  void map_clear_ex(map_t* map, void (*elem_clear_func)(const map_t* map, void* elem)); // Func ptr can be NULL, then same as map_clear
#+END_SRC

Implementations (can contains pseudo code):
#+NAME: hashmap_code
#+BEGIN_SRC C
  void* map_get(map_t* map, void* key) {
  	size_t hash = 0;
  	if (map->hash_func == NULL) {
  		if (map->key_size > 0) {
  			hash = default_hash_func((char*)key, map->key_size) % map->nbuckets;
  		} else {
  			hash = default_hash_func(*((char**)key), strlen(*((char**)key))) % map->nbuckets;
  		}
  	} else {
  		hash = map->hash_func(map, key) % map->nbuckets;
  	}
  	map_bucket_t* bucket = &map->buckets[hash];
  	if (map->keycmp_func == NULL) {
  		if (map->key_size > 0) {
  			for (size_t i = 0; i < bucket->nvals; i++) {
  				if(memcmp(key, (bucket->vals + (i * map->elem_size)), map->key_size) == 0) {
  					return (bucket->vals + (i * map->elem_size));
  				}
  			}
  		} else {
  			for (size_t i = 0; i < bucket->nvals; i++) {
  				if(strcmp(*((char**)key), *((char**)(bucket->vals + (i * map->elem_size)))) == 0) {
  					return (bucket->vals + (i * map->elem_size));
  				}
  			}
  		}
  	} else {
  		for (size_t i = 0; i < bucket->nvals; i++) {
  			if (map->keycmp_func(map, key, (bucket->vals + (i * map->elem_size)))) {
  				return (bucket->vals + (i * map->elem_size));
  			}
  		}
  	}
  	return NULL;
  }
  void* map_get_or_alloc(map_t* map, void* key) {
  	size_t hash = 0;
  	if (map->hash_func == NULL) {
  		if (map->key_size > 0) {
  			hash = default_hash_func((char*)key, map->key_size) % map->nbuckets;
  		} else {
  			hash = default_hash_func(*((char**)key), strlen(*((char**)key))) % map->nbuckets;
  		}
  	} else {
  		hash = map->hash_func(map, key) % map->nbuckets;
  	}
  	map_bucket_t* bucket = &map->buckets[hash];
  	if (map->keycmp_func == NULL) {
  		if (map->key_size > 0) {
  			for (size_t i = 0; i < bucket->nvals; i++) {
  				if(memcmp(key, (bucket->vals + (i * map->elem_size)), map->key_size) == 0) {
  					return (bucket->vals + (i * map->elem_size));
  				}
  			}
  		} else {
  			for (size_t i = 0; i < bucket->nvals; i++) {
  				if(strcmp(*((char**)key), *((char**)(bucket->vals + (i * map->elem_size)))) == 0) {
  					return (bucket->vals + (i * map->elem_size));
  				}
  			}
  		}
  	} else {
  		for (size_t i = 0; i < bucket->nvals; i++) {
  			if (map->keycmp_func(map, key, (bucket->vals + (i * map->elem_size)))) {
  				return (bucket->vals + (i * map->elem_size));
  			}
  		}
  	}
  	bucket->nvals++;
  	bucket->vals = realloc(bucket->vals, bucket->nvals * map->elem_size);
  	memset((char*)bucket->vals + (bucket->nvals - 1) * map->elem_size, 0, map->elem_size);
  	return bucket->vals + ((bucket->nvals - 1) * map_.elem_size)
  		}
  bool map_remove(map_t* map, void* key) {
  	// TODO
  }
  void map_clear(map_t* map) {
  	map_clear_ex(map, NULL);
  }
  void map_clear_ex(map_t* map, void (*elem_clear_func)(const map_t* map, void* elem)) {
  	if (elem_clear_func == NULL) {
  		for (size_t i = 0; i < map->nbuckets; i++) {
  			map_bucket_t* bucket = &map->buckets[i];
  			free(bucket->vals);
  			bucket->vals = NULL;
  			bucket->nvals = 0;
  		}
  		free(map->buckets);
  		map->buckets = NULL;
  		map->nbuckets = 0;
  	} else {
  		for (size_t i = 0; i < map->nbuckets; i++) {
  			map_bucket_t* bucket = &map->buckets[i];
  			for (size_t j = 0; j < bucket->nvals; j++) {
  				elem_clear_func(map, bucket->vals + (j * map->elem_size));
  			}
  			free(bucket->vals);
  			bucket->vals = NULL;
  			bucket->nvals = 0;
  		}
  		free(map->buckets);
  		map->buckets = NULL;
  		map->nbuckets = 0;
  	}
  }
#+END_SRC

** DONE Command.h process waiting

WARNING: AI code follows

Can be done using process groups:

#+NAME: proc_groups
#+BEGIN_SRC C
  // Set main proc as leader
  pid_t leader_pid = getpid();
  setpgid(0, leader_pid);
  // Wait for one proc to finish
  int status;
  pid_t done = waitpid(-group_pid, &status, 0);
  // Do something with pid
#+END_SRC

or signals:

#+NAME: proc_groups
#+BEGIN_SRC C
  volatile sig_atomic_t last_child_pid = 0;
  void sigchld_handler(int signo) {
  	int status;
  	pid_t pid = waitpid(-1, &status, WNOHANG);
  	if (pid > 0) {
  		last_child_pid = pid; // safe async-signal assignment
  	}
  }
  // main
  struct sigaction oldact, newact;
  newact.sa_handler = my_handler;
  sigemptyset(&newact.sa_mask);
  newact.sa_flags = SA_RESTART;
  // Set handler, save old handler
  if (sigaction(SIGCHLD, &newact, &oldact) < 0) {
  	perror("sigaction");
  	return 1;
  }
  // Spawn childs
  while (1) {
  	if (last_child_pid != 0) {
  		pid_t finished = last_child_pid;
  		last_child_pid = 0;
  		// handle finished child
  	}
  	pause(); // block until next signal
  }
  // Kill childs
  // Restore old handler
  if (sigaction(SIGCHLD, &oldact, NULL) < 0) {
  	perror("sigaction restore");
  	return 1;
  }
#+END_SRC

or just busy-loop on process list with ~waitpid(pid, &status NOHANG)~ and ~nanosleep~ to not fully busy-loop. This is actiully the best way (fastest/simplest)
or just wait for all process to finish (eg. run batch-by-batch), much easier but may be slower.

* Tests runner
*** DONE Make new shared header. Should load cbuild and have asserts.
*** DONE One test case per file
*** DONE New way of listing tests
File, human name, attributes (for which platform test can be used), argv for test, should test return 0 or 1 to succeed.
*** DONE Test runner
Just iterate over list of tests and then over a list of supported platforms. Test return 1/0. stdout is used by test. No more input/output can be used (except argv).
*** DONE New test reporting
For one-by-one runs do full logging
For batch runs do full logging (few tests specified on command line)
For full run just print table. Row - test case, column - platform. 4 possible report values.
 + "skipped" (gray '.') Test was marked as unsupported for platform
 + "passed" (green '+') Test return 0 code
 + "failed" (red '-') Test returned non-0 code
 + "comp-failed" (yellow '!') Test failed to compile (compiler returned non-0 code or binary was not produced)
* v0.13
*** Command.h rework
 + proper async
 + thread count control
 + Allow file redirects
*** Use proper argv[0]
* v0.xx
*** Make windows partially-supported target
Not everything can be ported to Windows with proper semantics
Waits for dexygen replacement. I want to be able to properly document this, and I can make wikimk do this. Maybe I will do it before this, but documentation will be broken.
*** CLI opts with '='

 #  LocalWords:  struct structs alloc
 
 
 
