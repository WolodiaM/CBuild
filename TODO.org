* Bugfix todo list

* Features todo list

*** TODO Map.h rewrite

I want to have a *plain*, *macro-based* map implementation.
I don't want to have a declaration macro, or it can define a list of structs at most.
I want to minimize usage of function pointers.
Macro should be relatively small.

*** TODO wikimk should not be a part of this repository

* Thinking place

** Hash-Map implementation

Pair struct can be provided by a used, bucket should be auto-generated, map should have an ability to add custom fields.
#+NAME: hashmap_struct
#+BEGIN_SRC C
  struct map_elem_t { // User provided
  	K key;
  	...
  };
  struct map_bucket_t { // Internal
  	void* vals;
  	size_t nvals;
  };
  struct map_t { // Internal
  	map_bucket* buckets;
  	size_t nbuckets;
  	size_t (*hash_func)(size_t key_size, void* key);             // Maybe internal, some tradeofs
  	bool (*keycmp_func)(size_t key_size, void* k1, void* k2);    // Maybe internal, memcmp
  	size_t key_size = sizeof(typeof(map_elem_t));
  	size_t elem_size = sizeof(typeof(map_elem_t));
  };
  struct my_map_t { // Autogenerated optionally
  	map_t map;
  	// Userdata
  }
  map_t* = (map_t*)&my_map_t;
  char[key_size] key = (char*)&map_elem_t;
#+END_SRC

API is based on a fact that map only require key to work. Data is completely user-defined. So let user play with it freely. Why limit to a ~val~ - let the user play with a full struct. Map only have one unified get interface that either return found element or allocate new based on key given.If allocations, memory will be zero-initialized and key will be unset. Then user can do anything with a struct (at least set a proper key ;). Map can provide additional macro that will abstract get and alloc operations and respective check (element exist or not).
API exposed:
#+NAME: hashmap_api
#+BEGIN_SRC C
  void* map_get_or_alloc(map_t* map, void* key);
  void map_clear(map_t* map);
#+END_SRC


Arguments: /*map/, /key/, /val/.
#+NAME: hasmap_set_macro
#+BEGIN_SRC C
  if (map->nbuckets == 0) {
  	log("ERROR");
  	return false;
  }
  size_t hash = map->hash_func(&key) % map->nbuckets;
  map_bucket_t* bucket = map->buckets[hash];
  for (size_t i = 0; i < bucket->nvals; i++) {
  	if(map->keycmp_func(&key, &bucket->vals[i].key)) {
  		bucket->vals[i].val = val;
  		return true;
  	}
  }
  bucket->nvals++;
  bucket->vals = realloc(bucket->vals, bucket->nvals * sizeof(map_bucket_t));
  assert(bucket->vals != NULL);
  bucket->vals[bucket->nvals-1] = {.key = key, .val = val};
  return true;
#+END_SRC

#  LocalWords:  struct structs alloc
