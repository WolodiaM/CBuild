---
title: Creating custom datatypes
---
# Working with datatypes

::: entry

CBuild provide multiple datatypes - dynamic array, string view, string buffer etc. `Map.h` uses older style of datatypes, which require separate init and only then types can be used. Init is done through a series of macro. Following code cwill create a map from `char*` to `int` named `cbuild_map_cstr_int_t`:

```c
bool cbuild_map_int_int_keycmp(int* k1, int* k2) {
    return strcmp(*k1, *k2) == 0;
}
size_t cbuild_map_int_int_hash(int* k) {
    return cbuild_map_string_hash(*k);
}
cbuild_map_t(char*, int, cstr, int);
cbuild_da_t_impl(char*, int, cstr, int);
```

This code can be used to expose map into another C file:

```c
cbuild_map_t(char*, int, cstr, int);
cbuild_map_t_ext_impl(cstr, int);
```

But other types are using newer approach. You need to define structs that have specific fields and then you can use provided macro on that fields. So, to create a new dynamic array you can simply do. Following codde will create dynamic array of ints. Then any `cbuild_da_*` function can be used on this struct:

```c
typedef struct my_da_t {
    int* data;
    size_t size;
    size_t capacity;
} my_da_t;
```

This simplify working with types a lot. For example, this is init of map and da side-by-side:

```c
cbuild_map_cstr_int_t map = cbuild_map_cstr_int;
my_da_t da = {0};
```

Also, this allow to add custom fileds to a struct easily. You can this done in [Command.h](/doxygen/structcbuild__cmd__t.html). There, `cbuild_cmd_t` is a standard dynamic array, but it have another fields, that is specifc to this struct.

To create a new stack this struct should be created:

```c
typedef struct my_stack_t {
    int* data;
    size_t ptr;
    size_t capacity;
} my_stack_t;
```

:::